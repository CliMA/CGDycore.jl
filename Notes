julia> x = [1,2]
2-element Vector{Int64}:
 1
 2

julia> typeof(x)
Vector{Int64} (alias for Array{Int64, 1})

julia> using StaticArrays
 │ Package StaticArrays not found, but a package named StaticArrays is available
 │ from a registry.
 │ Install package?
 │   (@v1.7) pkg> add StaticArrays
 └ (y/n) [y]:
    Updating registry at `~/.julia/registries/General.toml`
   Resolving package versions...
    Updating `~/.julia/environments/v1.7/Project.toml`
  [90137ffa] + StaticArrays v1.4.3
    Updating `~/.julia/environments/v1.7/Manifest.toml`
  [90137ffa] + StaticArrays v1.4.3
Precompiling project...
  21 dependencies successfully precompiled in 46 seconds (28 already precompiled)

julia> x = @SVector [1.0,2.0]
2-element SVector{2, Float64} with indices SOneTo(2):
 1.0
 2.0

julia> @code_warntype length(x)
MethodInstance for length(::SVector{2, Float64})
  from length(a::Union{LinearAlgebra.Adjoint{T, <:Union{StaticVector{<:Any, T}, StaticMatrix{<:Any, <:Any, T}}}, LinearAlgebra.Diagonal{T, <:StaticVector{<:Any, T}}, LinearAlgebra.Hermitian{T, <:StaticMatrix{<:Any, <:Any, T}}, LinearAlgebra.LowerTriangular{T, <:StaticMatrix{<:Any, <:Any, T}}, LinearAlgebra.Symmetric{T, <:StaticMatrix{<:Any, <:Any, T}}, LinearAlgebra.Transpose{T, <:Union{StaticVector{<:Any, T}, StaticMatrix{<:Any, <:Any, T}}}, LinearAlgebra.UnitLowerTriangular{T, <:StaticMatrix{<:Any, <:Any, T}}, LinearAlgebra.UnitUpperTriangular{T, <:StaticMatrix{<:Any, <:Any, T}}, LinearAlgebra.UpperTriangular{T, <:StaticMatrix{<:Any, <:Any, T}}, StaticVector{<:Any, T}, StaticMatrix{<:Any, <:Any, T}, StaticArray{<:Tuple, T}} where T) in StaticArrays at /Users/simon/.julia/packages/StaticArrays/12k3X/src/abstractarray.jl:1
Arguments
  #self#::Core.Const(length)
  a::SVector{2, Float64}
Body::Int64
1 ─ %1 = StaticArrays.Size(a)::Core.Const(Size(2,))
│   %2 = StaticArrays.prod(%1)::Core.Const(2)
│   %3 = Core.typeassert(%2, StaticArrays.Int)::Core.Const(2)
└──      return %3


julia> y = [1.0, 2.0]
2-element Vector{Float64}:
 1.0
 2.0

julia> @code_warntype length(y)
MethodInstance for length(::Vector{Float64})
  from length(a::Array) in Base at array.jl:215
Arguments
  #self#::Core.Const(length)
  a::Vector{Float64}
Body::Int64
1 ─ %1 = Base.arraylen(a)::Int64
└──      return %1


julia> const N = 2
2

julia> f() = N
f (generic function with 1 method)

julia> @code_warntype f()
MethodInstance for f()
  from f() in Main at REPL[9]:1
Arguments
  #self#::Core.Const(f)
Body::Int64
1 ─     return Main.N


julia> f(x) = N
f (generic function with 2 methods)

julia> @code_warntype f(x)
MethodInstance for f(::SVector{2, Float64})
  from f(x) in Main at REPL[11]:1
Arguments
  #self#::Core.Const(f)
  x::SVector{2, Float64}
Body::Int64
1 ─     return Main.N


julia> @code_llvm f(x)
;  @ REPL[11]:1 within `f`
define i64 @julia_f_736([1 x [2 x double]]* nocapture nonnull readonly align 8 dereferenceable(16) %0) #0 {
top:
  ret i64 2
}

julia>

julia> Val(2)
Val{2}()

julia> f(::Val{N}) where {N} = N
f (generic function with 3 methods)

julia> f(::Val{N}) where {N} = N + 3
f (generic function with 3 methods)

julia> f(Val(3))
6

julia> @code_warntype f(Val(3))
MethodInstance for f(::Val{3})
  from f(::Val{N}) where N in Main at REPL[16]:1
Static Parameters
  N = 3
Arguments
  #self#::Core.Const(f)
  _::Core.Const(Val{3}())
Body::Int64
1 ─ %1 = ($(Expr(:static_parameter, 1)) + 3)::Core.Const(6)
└──      return %1


julia> v = Val(6)
Val{6}()

julia> function divergence(v1,v2,v3,::Val{Nq})
       end
ERROR: UndefVarError: Nq not defined
Stacktrace:
 [1] top-level scope
   @ REPL[20]:1

julia> function divergence(v1,v2,v3,::Val{Nq}) where {Nq}
       end
divergence (generic function with 1 method)

julia> function divergence(v1,v2,v3,::Val{Nq}) where {Nq}
         Nq*3
         end
divergence (generic function with 1 method)

julia> divergence(x,x,x,Val(2))
6

julia> @code_warntype divergence(x,x,x,Val(2))
MethodInstance for divergence(::SVector{2, Float64}, ::SVector{2, Float64}, ::SVector{2, Float64}, ::Val{2})
  from divergence(v1, v2, v3, ::Val{Nq}) where Nq in Main at REPL[22]:1
Static Parameters
  Nq = 2
Arguments
  #self#::Core.Const(divergence)
  v1::SVector{2, Float64}
  v2::SVector{2, Float64}
  v3::SVector{2, Float64}
  _::Core.Const(Val{2}())
Body::Int64
1 ─ %1 = ($(Expr(:static_parameter, 1)) * 3)::Core.Const(6)
└──      return %1


julia> @threads for e in elements
         divergence(V[e])
       end
ERROR: LoadError: UndefVarError: @threads not defined
in expression starting at REPL[25]:1

julia> A = zeros(Threads.nthreads())
1-element Vector{Float64}:
 0.0

julia> @threads for e in elements
       A[Threads.threadi
threadid      threading_run
julia> @threads for e in elements
       A[Threads.threadid()] += ...
ERROR: syntax: invalid identifier name "..."
Stacktrace:
 [1] top-level scope
   @ none:1
