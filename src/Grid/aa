  !> Go to the nearest grid cell in the ICON grid 
  !!
  !! Search for nearest grid point for given (geographical) target coordinates.
  !! Walk from a (given) starting cell in the direction of the target coordintes
  !! until the neighbour cells have a larger distance to the current cell.
  !! This algorithm works on global domains, for regional domains the search
  !! might get stuck at the boundaries of the domains.
  SUBROUTINE walk_to_nc ( grid,              &
       &                  target_cc_co,      &
       &                  start_cell_id,     &
       &                  nvertex_per_cell,  &
       &                  ncells_per_vertex, &
       &                  nearest_cell_id )

    TYPE(icon_domain), INTENT(IN)               :: grid              !> Data structure with ICON grid
    TYPE(cartesian_coordinates), INTENT(IN)     :: target_cc_co     
    !>  target coordinates in cartesian system of point for which the nearest ICON grid cell is to be determined
    INTEGER (KIND=i4), INTENT(INOUT)            :: start_cell_id     !> id of starting cell
    INTEGER, INTENT(IN)                         :: nvertex_per_cell  !< number of vertices per cell
    INTEGER, INTENT(IN)                         :: ncells_per_vertex !< number of cells per vertex
    INTEGER (KIND=i4), INTENT(OUT)              :: nearest_cell_id   !> id of nearest cell

    ! local variables
    TYPE(cartesian_coordinates)  :: cell_cc          !> coordinates of cell centre in cartesian system 
    TYPE(cartesian_coordinates)  :: neighbour_cc     !> coordinates of a neighbour cell centre in cartesian system
    INTEGER                      :: nb_cell_id       !> neighbour cell id

    INTEGER   (KIND=i4)          :: current_cell_id
    INTEGER   (KIND=i4)          :: next_cell_id

    REAL(KIND=wp)                :: sp               
    !> cos arc length of  of geodesic arc with endpoints x0,x1 (normalized scalar product of the two points)
    REAL(KIND=wp)                :: sp_max           !> maximum of the scalar product of two points (minimal distance)

    LOGICAL                      :: searching

    INTEGER                      :: nj               !< counter

    searching = .TRUE.   ! set searching to "true"

    nearest_cell_id = start_cell_id ! initial setting
    current_cell_id = start_cell_id ! initial setting
    next_cell_id    = start_cell_id ! initial setting 

    ! cartesian coordinates of start cell centre
    cell_cc =  grid%cells%cc_center(start_cell_id)

    ! calculate a measure for the distance to target point
    sp = scal_pro(target_cc_co, cell_cc)
    sp_max = sp

    DO WHILE(searching)
      searching = .false. ! abort condition
      DO nj=1, nvertex_per_cell
        nb_cell_id = grid%cells%neighbor_index(current_cell_id,nj) ! get cell id of neighbour cells
        IF (nb_cell_id > 0 ) THEN                                  ! 0 is the "undefined" value for the cell id
          neighbour_cc = grid%cells%cc_center(nb_cell_id)          ! get cartesian coordinates of neighbour cell
          sp = scal_pro(target_cc_co,neighbour_cc)                 ! calculate measure for distance to target point
          IF (sp > sp_max) THEN                                    ! if neighbour cell is nearer to target point than the "old" cell
            sp_max = sp                                            ! save new distance measure
            next_cell_id = nb_cell_id                              ! save cell id
            searching = .true.                                     ! continue with search loop
          ENDIF
        ENDIF
      ENDDO
      current_cell_id = next_cell_id       ! move one cell toward target point
    ENDDO
    nearest_cell_id = current_cell_id      ! set nearest_cell_id to the cell id
                                           ! which has smallest distance (i.e. largest sp) to target point

    ! check with a point in polygon test
    CALL control_nc( grid,              &
         &           target_cc_co,      &
         &           ncells_per_vertex, &
         &           nvertex_per_cell,  &
         &           nearest_cell_id )

    ! save the start cell ID for next search point
    ! if it is zero, it will be reinitialized from the search index list in the calling program
    start_cell_id = nearest_cell_id

  END SUBROUTINE walk_to_nc
