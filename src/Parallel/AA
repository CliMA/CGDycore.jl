void eq_regions(int N, double xmin[], double xmax[], double ymin[], double ymax[]) {
    // EQ_REGIONS Recursive zonal equal area (EQ) partition of sphere
    //
    // Syntax
    //  [regions,dim_1_rot] = eq_regions(dim,N,options);
    //
    // Description
    //  REGIONS = EQ_REGIONS(dim,N) uses the recursive zonal equal area sphere
    //  partitioning algorithm to partition S^dim (the unit sphere in dim+1
    //  dimensional space) into N regions of equal area and small diameter.
    //
    //  The arguments dim and N must be positive integers.
    //
    //  The result REGIONS is a (dim by 2 by N) array, representing the regions
    //  of S^dim. Each element represents a pair of vertex points in spherical
    //  polar
    //  coordinates.
    //
    //  Each region is defined as a product of intervals in spherical polar
    //  coordinates. The pair of vertex points regions(:,1,n) and regions(:,2,n)
    //  give
    //  the lower and upper limits of each interval.
    //
    //  REGIONS = EQ_REGIONS(dim,N,'offset','extra') uses experimental extra
    //  offsets for S^2 and S^3 to try to minimize energy. If dim > 3, extra
    //  offsets
    //  are not used.
    //
    //  REGIONS = EQ_REGIONS(dim,N,extra_offset) uses experimental extra offsets
    //  if extra_offset is true or non-zero.
    //
    //  [REGIONS,DIM_1_ROT] = EQ_REGIONS(dim,N) also returns DIM_1_ROT, a cell
    //  array containing N rotation matrices, one per region, each of size dim by
    //  dim.
    //  These describe the R^dim rotation needed to place the region in its final
    //  position.
    //
    //  [REGIONS,DIM_1_ROT] = EQ_REGIONS(dim,N,'offset','extra') partitions S^dim
    //  into N regions, using extra offsets, and also returning DIM_1_ROT, as
    //  above.
    //

    if (N == 1) {
        //
        // We have only one region, which must be the whole sphere.
        //
        xmin[0] = 0.;
        ymin[0] = -0.5 * M_PI;
        xmax[0] = 2. * M_PI;
        ymax[0] = 0.5 * M_PI;
        return;
    }
    //
    // Start the partition of the sphere into N regions by partitioning
    // to caps defined in the current dimension.
    //
    std::vector<int> n_regions;
    std::vector<double> s_cap;
    eq_caps(N, n_regions, s_cap);
    //
    // s_cap is an increasing list of colatitudes of the caps.
    //
    //
    // We have a number of zones: two polar caps and a number of collars.
    // n_regions is the list of the number of regions in each zone.
    //
    int n_collars = n_regions.size() - 2;
    //
    // Start with the top cap.
    //
    xmin[0] = 0.;
    ymin[0] = 0.5 * M_PI - s_cap[0];
    xmax[0] = 2. * M_PI;
    ymax[0] = 0.5 * M_PI;

    int region_n = 1;
    for (int collar_n = 0; collar_n < n_collars; ++collar_n) {
        for (int region_ew = 0; region_ew < n_regions[collar_n + 1]; ++region_ew) {
            xmin[region_n] = 2. * M_PI / (static_cast<double>(n_regions[collar_n + 1])) * region_ew;
            ymin[region_n] = 0.5 * M_PI - s_cap[collar_n + 1];
            xmax[region_n] = 2. * M_PI / (static_cast<double>(n_regions[collar_n + 1])) * (region_ew + 1.);
            ymax[region_n] = 0.5 * M_PI - s_cap[collar_n];
            ++region_n;
        }
    }
    //
    // End with the bottom cap.
    //
    xmin[N - 1] = 0.;
    ymin[N - 1] = -0.5 * M_PI;
    xmax[N - 1] = 2. * M_PI;
    ymax[N - 1] = 0.5 * M_PI - s_cap[s_cap.size() - 2];
}
