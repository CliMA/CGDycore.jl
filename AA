@kernel function HyperViscTracerKernel!(FTr,@Const(Tr),@Const(Rho),@Const(D),@Const(DW),@Const(dXdxI),
  @Const(JJ),@Const(M),@Const(Glob)) 

  I, J, iz   = @index(Local, NTuple)
  _,_,Iz,IF = @index(Global, NTuple)

  ColumnTilesDim = @uniform @groupsize()[3]
  N = @uniform @groupsize()[1]
  Nz = @uniform @ndrange()[3]
  NF = @uniform @ndrange()[4]

  ID = I + (J - 1) * N  
  @inbounds ind = Glob[ID,IF]

  TrCol = @localmem eltype(FTr) (N,N, ColumnTilesDim)
  TrCxCol = @localmem eltype(FTr) (N,N, ColumnTilesDim)
  TrCyCol = @localmem eltype(FTr) (N,N, ColumnTilesDim)
  if Iz <= Nz && IF <= NF
    @inbounds TrCol[I,J,iz] = Tr[Iz,ind] / Rho[Iz,ind]
  end
  @synchronize

  ID = I + (J - 1) * N  
  @inbounds ind = Glob[ID,IF]

  if Iz <= Nz && IF <= NF
    @inbounds Dxc = D[I,1] * TrCol[1,J,iz]
    @inbounds Dyc = D[J,1] * TrCol[I,1,iz]
    for k = 2 : N
      @inbounds Dxc += D[I,k] * TrCol[k,J,iz]
      @inbounds Dyc += D[J,k] * TrCol[I,k,iz] 
    end
    @views @inbounds (GradDx, GradDy) = Grad12(Dxc,Dyc,dXdxI[1:2,1:2,:,ID,Iz,IF],JJ[ID,:,Iz,IF])
    @views @inbounds (tempx, tempy) = Contra12(GradDx,GradDy,dXdxI[1:2,1:2,:,ID,Iz,IF])
    @inbounds TrCxCol[I,J,iz] = tempx
    @inbounds TrCyCol[I,J,iz] = tempy
  end

  @synchronize 

  ID = I + (J - 1) * N  
  @inbounds ind = Glob[ID,IF]
  if Iz <= Nz && IF <= NF
    @inbounds DivTr = DW[I,1] * TrCxCol[1,J,iz] + DW[J,1] * TrCyCol[I,1,iz]
    for k = 2 : N
      @inbounds DivTr += DW[I,k] * TrCxCol[k,J,iz] + DW[J,k] * TrCyCol[I,k,iz]
    end
    @inbounds @atomic FTr[Iz,ind] += DivTr / M[Iz,ind]
  end
end
