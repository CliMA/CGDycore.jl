#=
@kernel function RotKernel!(Rot,@Const(U),@Const(D),@Const(dXdxI),
  @Const(JJ),::Val{BANK}=Val(1)) where BANK

  gi, gz, gF = @index(Group, NTuple)
  ID, iz   = @index(Local, NTuple)
  _,_,IF = @index(Global, NTuple)

  ColumnTilesDim = @uniform @groupsize()[2]
  N = @uniform size(D,1)
  Nz = @uniform @ndrange()[2]
  NF = @uniform @ndrange()[3]

  @uniform ColumnTiles = (div(Nz - 1, ColumnTilesDim) + 1) * NF
  RotLoc = @localmem eltype(F) (N,N,ColumnTilesDim)

  Iz = (gz - 1) * ColumnTilesDim + iz
  I = div(ID,N)
  J = div(Ind-I,N) + 1
  if Iz <= Nz 
    @inbounds tempx = ((dXdxID[1,1,1,ID,iz] + dXdxID[1,1,2,:,:,iz]) * vC[ID,iz] - 
      (dXdxID[1,2,1,ID,iz] + dXdxID[1,2,2,ID,iz]) * uC[ID,iz])
    @inbounds tempy = ((dXdxI[2,1,1,ID,iz] + dXdxI[2,1,2,ID,iz]) * vC[ID,iz] - 
      (dXdxI[2,2,1,ID,iz] + dXdxI[2,2,2,I,iz]) * uC[ID,iz])
    for k = 1 : N
      @inbounds @atomic RotLoc[k,J,iz] += D[k,I] * tempx
      @inbounds @atomic RotLoc[I,k,iz] += D[k,J] * tempy
    end
  end

  @synchronize
  Iz = (gz - 1) * ColumnTilesDim + iz
  if Iz <= Nz 
    for j = 1 : size(Inter,1) 
      for i = 1 : size(Inter,2) 
        @inbounds @atomic Rot[i,j,iz,IF] += Inter[i,j,I,J] * RotLoc[I,J]  
      end    
    end    
  end    

end  
=#
