@kernel inbounds = true function AdvectionTrUpwind3Kernel!(FTr,@Const(Tr),@Const(U),@Const(w),@Const(D),@Const(dXdxI),
  @Const(JJ),@Const(M),@Const(Glob))

  I, J, iz   = @index(Local, NTuple)
  _,_,Iz,IF,IE = @index(Global, NTuple)

  ColumnTilesDim = @uniform @groupsize()[3]
  N = @uniform @groupsize()[1]
  Nz = @uniform @ndrange()[3]
  NF = @uniform @ndrange()[4]
  NE = @uniform @ndrange()[5]

  ID = I + (J - 1) * N  
  ind = Glob[ID,IF]

  cCol = @localmem eltype(FTr) (N,N, ColumnTilesDim+3)
  if Iz <= Nz
    cCol[I,J,iz+1] = Tr[Iz,ind,IE]
  end
  if iz == 1
    Izm1 = max(Iz - 1,1)
    cCol[I,J,iz] = Tr[Izm1,ind,IE] 
  end
  if iz == ColumnTilesDim || Iz == Nz
    Izp1 = min(Iz + 1,Nz)
    cCol[I,J,iz+2] = Tr[Izp1,ind,IE]
    Izp2 = min(Iz + 2,Nz)
    cCol[I,J,iz+3] = Tr[Izp2,ind,IE]
  end
  @synchronize

  ID = I + (J - 1) * N  
  ind = Glob[ID,IF]

  if Iz < Nz 
    cLL = cCol[I,J,iz]
    cL = cCol[I,J,iz+1]
    cR = cCol[I,J,iz+2]
    cRR = cCol[I,J,iz+3]

    @views wCon = Contra3(U[Iz:Iz+1,ind,2],U[Iz:Iz+1,ind,3],
      w[Iz,ind],dXdxI[3,:,:,ID,Iz:Iz+1,IF])

    Izm1 = max(Iz - 1,1)
    Izp2 = min(Iz + 2, Nz)
    JLL = JJ[ID,1,Izm1,IF] + JJ[ID,2,Izm1,IF]
    JL = JJ[ID,1,Iz,IF] + JJ[ID,2,Iz,IF]
    JR = JJ[ID,1,Iz+1,IF] + JJ[ID,2,Iz+1,IF]
    JRR = JJ[ID,1,Izp2,IF] + JJ[ID,2,Izp2,IF]
    cFL, cFR = RecU4(cLL,cL,cR,cRR,JLL,JL,JR,JRR) 
    Flux = eltype(FTr)(0.25) * ((abs(wCon) + wCon) * cFL + (-abs(wCon) + wCon) * cFR)
    @atomic :monotonic FTr[Iz,ind,IE] += (-Flux + wCon * cL) / M[Iz,ind] 
    @atomic :monotonic FTr[Iz+1,ind,IE] += (Flux - wCon * cR) / M[Iz+1,ind]
  end 

  if Iz <= Nz
    GradxTr = D[I,1] * cCol[1,J,iz+1] 
    GradyTr = D[J,1] * cCol[I,1,iz+1]
    for k = 2 : N
      GradxTr += D[I,k] * cCol[k,J,iz+1] 
      GradyTr += D[J,k] * cCol[I,k,iz+1]
    end
    @views (uCon, vCon) = Contra12(U[Iz,ind,2],U[Iz,ind,3],dXdxI[1:2,1:2,:,ID,Iz,IF])
    @atomic :monotonic FTr[Iz,ind,IE] += -(GradxTr * uCon + GradyTr * vCon) / M[Iz,ind]
  end
end
