function gaussian_smooth(arr::AbstractArray, sigma::Int = 1)
    n1, n2 = size(arr)

    # We assume that the Gaussian goes to zero at 10 sigma and ignore contributions outside of that window
    window = Int(ceil(10 * sigma))

    # Prepare the 2D Gaussian kernel
    gauss = [
        exp.(-(x .^ 2 .+ y .^ 2) / (2 * sigma^2)) for
        x in range(-window, window), y in range(-window, window)
    ]

    # Normalize it
    gauss = gauss / sum(gauss)

    smoothed_arr = zeros(size(arr))

    # 2D convolution
    for i in 1:n1
        for j in 1:n2
            # For each point, we "look left and right (up and down)" within our window
            for wx in (-window):window
                for wy in (-window):window
                    # For values at the edge, we keep using the edge value
                    k = clamp(i + wx, 1, n1)
                    l = clamp(j + wy, 1, n2)

                    # gauss has size 2window + 1, so its midpoint (when the gaussian is max)
                    # is at 1 + window
                    #
                    # Eg, for window of 3, wx will go through the values -3, -2, 1, 0, 1, 2, 3,
                    # and the midpoint is 4 (= 1 + window)
                    mid_gauss_idx = 1 + window

                    smoothed_arr[i, j] +=
                        arr[k, l] *
                        gauss[mid_gauss_idx + wx, mid_gauss_idx + wy]
                end
            end
        end
    end

    return smoothed_arr
end
