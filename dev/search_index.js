var documenterSearchIndex = {"docs":
[{"location":"MassMatrix/#Massmatrix","page":"Mass Matrix","title":"Massmatrix","text":"","category":"section"},{"location":"MassMatrix/","page":"Mass Matrix","title":"Mass Matrix","text":"The mass matrix represents the inner product in the discretized function space.","category":"page"},{"location":"MassMatrix/","page":"Mass Matrix","title":"Mass Matrix","text":"For efficiency, we avoid explicitly assembling the mass matrix and instead","category":"page"},{"location":"MassMatrix/","page":"Mass Matrix","title":"Mass Matrix","text":"apply its action directly to fields.","category":"page"},{"location":"MassMatrix/","page":"Mass Matrix","title":"Mass Matrix","text":"In Julia, this is often achieved using matrix-free methods and","category":"page"},{"location":"MassMatrix/","page":"Mass Matrix","title":"Mass Matrix","text":"broadcasting, enabling efficient and flexible computations.","category":"page"},{"location":"MassMatrix/","page":"Mass Matrix","title":"Mass Matrix","text":"The mass matrix acts as a \"pseudo-operator\": it cannot be called directly, but can be applied to fields in a manner similar to other operators, leveraging broadcasting for performance and composability.","category":"page"},{"location":"MassMatrix/#General-Usage","page":"Mass Matrix","title":"General Usage","text":"","category":"section"},{"location":"MassMatrix/#CGDycore.FEMSei.MassMatrix","page":"Mass Matrix","title":"CGDycore.FEMSei.MassMatrix","text":"MassMatrix H(curl) elements\n\nAssembles the global mass matrix for a finite element discretization using H(curl) elements.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: Finite element basis or transformation object.\nFe::HCurlElement: The finite element object containing basis functions and related data for H(curl) elements.\nGrid: The computational grid or mesh structure containing faces and geometry information.\nQuadOrd: The order of the quadrature rule to use for numerical integration.\nJacobi: Function that computes the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nReturns\n\nM: The assembled sparse global mass matrix as a SparseMatrixCSC.\n\nDescription\n\nFor each face in the grid, the function computes the local mass matrix by integrating the inner product of the mapped basis functions over the reference element using a specified quadrature rule. The local contributions are then assembled into the global sparse mass matrix. Only non-negligible entries (greater than 1.e-6 in magnitude) are included in the global matrix.\n\nNotes\n\nThe function assumes that the basis functions and their mapping are provided in the Fe object.\nThe Jacobian and its pseudo-inverse are used to map basis functions from the reference to the physical element.\nThe function is tailored for H(curl) elements and may require adaptation for other element types.\n\n\n\n\n\nMassMatrix H(div) elements\n\nAssembles the global mass matrix for a finite element space defined by Fe over the mesh Grid using a specified quadrature order QuadOrd and a Jacobian computation function Jacobi.\n\nArguments\n\nbackend: Computational backend to use (not used directly in this function).\nFTB: Finite element type or basis (not used directly in this function).\nFe::HDivElement: Finite element object containing basis functions, degrees of freedom, and global indexing.\nGrid: Mesh/grid object containing face information and geometry.\nQuadOrd: Integer specifying the order of the quadrature rule.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nReturns\n\nM: Sparse matrix representing the assembled global mass matrix.\n\nDetails\n\nFor each face in the mesh, the function computes the local mass matrix using numerical quadrature.\nBasis functions are evaluated at quadrature points and mapped to the physical element using the Jacobian.\nThe local mass matrix contributions are assembled into the global sparse matrix using the global degree of freedom indices.\nEntries with absolute value less than 1e-12 are ignored for sparsity.\n\nNotes\n\nThe function assumes that the finite element basis functions are provided as callable objects in Fe.phi.\nThe function is tailored for H(div)-conforming elements, where basis functions are vector-valued.\n\n\n\n\n\nMassMatrix Scalar elements\n\nAssembles the global mass matrix for a finite element mesh.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: Finite element type or basis information.\nFe::ScalarElement: Scalar finite element object containing basis functions and related data.\nGrid: Grid or mesh structure containing information about faces and connectivity.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and its pseudo-inverse for mapping reference to physical elements.\n\nReturns\n\nM: Sparse matrix representing the assembled global mass matrix.\n\nDescription\n\nThis function computes the mass matrix by looping over all faces in the mesh, evaluating basis functions at quadrature points, and assembling local contributions into the global sparse matrix. The Jacobian is used to map reference element integrals to the physical domain. Only nonzero entries are stored in the sparse matrix.\n\nNotes\n\nThe function assumes that Fe.phi contains callable basis functions.\nThe global degree of freedom mapping is provided by Fe.Glob.\nThe quadrature rule is determined by FEMSei.QuadRule.\n\n\n\n\n\nMassMatrix Scalar elements with weights\n\nAssembles the mass matrix for a finite element method (FEM) problem using the provided scalar elements, quadrature order, and grid information.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: Finite element basis or related data structure.\nFe::ScalarElement: Finite element object representing the trial space.\nw: Vector of weights or coefficients for the weighted mass matrix.\nwFe::ScalarElement: Finite element object representing the weighting/test space.\nGrid: Grid or mesh data structure containing faces and connectivity.\nQuadOrd: Integer specifying the quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nReturns\n\nM: Sparse matrix representing the assembled mass matrix.\n\nDescription\n\nThe function computes the local mass matrix for each face in the grid using numerical quadrature, basis functions, and the provided weights. It then assembles these local matrices into a global sparse mass matrix. The Jacobian is used to map quadrature points from the reference element to the physical element, and the determinant is used to scale the integration weights.\n\nNotes\n\nThe function assumes that the basis functions (phi) are provided as callable objects in Fe and wFe.\nThe global indices for assembling the sparse matrix are taken from Fe.Glob and wFe.Glob.\nThe function supports assembling weighted mass matrices by incorporating the vector w and its associated basis functions.\n\n\n\n\n\nMassMatrix Vector elements\n\nAssembles the global mass matrix for a finite element discretization.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: Finite element type or basis information.\nFe::VectorElement: Finite element object containing basis functions, degrees of freedom, and global mapping.\nGrid: Grid or mesh structure containing face and connectivity information.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nReturns\n\nM: Sparse matrix representing the assembled global mass matrix.\n\nDescription\n\nFor each face in the grid, this function computes the local mass matrix using numerical quadrature and the provided basis functions. The local contributions are then assembled into the global sparse mass matrix using the global degree of freedom mapping.\n\nNotes\n\nThe function assumes 2D elements and vector-valued basis functions.\nThe quadrature rule and basis function evaluations are performed on the reference element and mapped to the physical element using the Jacobian.\nOnly nonzero entries are stored in the sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#Stiffness-Matrix","page":"Stiffness Matrix","title":"Stiffness Matrix","text":"","category":"section"},{"location":"StiffMatrix/","page":"Stiffness Matrix","title":"Stiffness Matrix","text":"The stiffness matrix represents the discretized weak form of differential operators (e.g., curl-curl, grad-div, Laplacian) in finite element methods.","category":"page"},{"location":"StiffMatrix/","page":"Stiffness Matrix","title":"Stiffness Matrix","text":"It encodes the action of the differential operator on the chosen basis functions.\nThe stiffness matrix is typically sparse and symmetric (for self-adjoint operators).\nEfficient assembly and application are crucial for large-scale simulations.","category":"page"},{"location":"StiffMatrix/#StiffMatrix-in-FEMSei","page":"Stiffness Matrix","title":"StiffMatrix in FEMSei","text":"","category":"section"},{"location":"StiffMatrix/","page":"Stiffness Matrix","title":"Stiffness Matrix","text":"The StiffMatrix function assembles the global stiffness matrix for various finite element types (e.g., HCurlElement, HDivElement, ScalarElement, VectorElement).   It uses numerical quadrature and the mapping from reference to physical elements.","category":"page"},{"location":"StiffMatrix/#General","page":"Stiffness Matrix","title":"General","text":"","category":"section"},{"location":"StiffMatrix/#CGDycore.FEMSei.VortCrossVel!","page":"Stiffness Matrix","title":"CGDycore.FEMSei.VortCrossVel!","text":"VortCrossVel!(backend, FTB, Rhs, u, uFe::HDivConfElement, q, qFe::ScalarElement, FeT::HDivConfElement, Grid, QuadOrd, Jacobi)\n\nAssembles the right-hand side (Rhs) vector for the vorticity-cross-velocity term in a finite element method (FEM) context, specifically for mixed HDiv and scalar elements.\n\nArguments\n\nbackend: Computational backend or context (e.g., CPU/GPU).\nFTB: (Unused in this function) Placeholder for future extensions or backend-specific data.\nRhs: The right-hand side vector to be assembled (modified in-place).\nu: Coefficient vector for the velocity field.\nuFe::HDivConfElement: HDiv-conforming finite element description for the velocity field.\nq: Coefficient vector for the scalar field (e.g., vorticity or pressure).\nqFe::ScalarElement: Scalar finite element description for the scalar field.\nFeT::HDivConfElement: HDiv-conforming finite element description for the test functions.\nGrid: Grid or mesh data structure containing geometry and connectivity.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nDescription\n\nFor each face in the grid, this function:\n\nEvaluates basis functions and their values at quadrature points.\nComputes the local contributions to the right-hand side vector by integrating the vorticity-cross-velocity term using the provided quadrature rule.\nApplies the transformation from reference to physical element using the Jacobian.\nAccumulates the local contributions into the global Rhs vector.\n\nNotes\n\nAssumes that the basis functions and their global-to-local mappings are provided in the finite element objects.\nUses in-place operations and preallocated arrays for efficiency.\nThe function is intended for use in mixed finite element formulations involving HDiv and scalar elements.\n\nSee also\n\nHDivConfElement\nScalarElement\nQuadRule\nJacobi\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#CGDycore.FEMSei.DivMatrix","page":"Stiffness Matrix","title":"CGDycore.FEMSei.DivMatrix","text":"DivMatrix(backend, FTB, FeF::HDivConfElement, FeT::ScalarElement, Grid, QuadOrd, Jacobi)\n\nAssembles the divergence matrix for a finite element method (FEM) problem, coupling an HDivConfElement (face element) and a ScalarElement (cell element) over a given grid.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: Additional backend or finite element type information.\nFeF::HDivConfElement: The face finite element with divergence basis functions.\nFeT::ScalarElement: The scalar finite element with basis functions.\nGrid: The grid structure containing mesh and face information.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nReturns\n\nDiv: A sparse matrix representing the divergence operator assembled over the grid.\n\nDetails\n\nUses quadrature to integrate the product of test and trial functions (and their divergences) over each face in the grid.\nHandles mapping from reference to physical elements using the provided Jacobi function.\nAssembles the global sparse matrix using local contributions from each face.\n\nNotes\n\nAssumes that FeT.phi and FeF.Divphi are arrays of functions for evaluating basis functions and their divergences at quadrature points.\nThe orientation of each face is taken into account via Grid.Faces[iF].Orientation.\n\n\n\n\n\nDivMatrix(backend, FTB, FeF::HDivKiteDElement, FeT::ScalarElement, Grid, QuadOrd, Jacobi)\n\nAssembles the divergence matrix for a finite element method (FEM) discretization using HDiv-conforming kite elements (FeF) and scalar elements (FeT) on a given grid.\n\nArguments\n\nbackend: Computational backend to use (e.g., for parallelization or hardware selection).\nFTB: Additional backend or finite element type information (usage context-dependent).\nFeF::HDivKiteDElement: The HDiv-conforming finite element for the faces (vector-valued).\nFeT::ScalarElement: The scalar finite element for the target space (scalar-valued).\nGrid: The computational grid containing geometry and topology information.\nQuadOrd: The order of the quadrature rule to use for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nReturns\n\nDiv: A sparse matrix representing the divergence operator assembled over all faces of the grid.\n\nDetails\n\nComputes basis function values and their divergences at quadrature points on both the reference element and its edges.\nIntegrates the contributions using quadrature rules for both the element interior and its boundaries.\nAssembles the local divergence matrices into a global sparse matrix using global degree-of-freedom (DoF) mappings.\nHandles orientation and geometry transformations via the provided Jacobi function.\n\nNotes\n\nThe function assumes that the basis functions and their divergences are provided as callable objects in FeT.phi, FeF.phi, and FeF.Divphi.\nThe grid and element structures must provide necessary geometric and topological information, including face orientations and global DoF mappings.\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#CGDycore.FEMSei.LaplMatrix","page":"Stiffness Matrix","title":"CGDycore.FEMSei.LaplMatrix","text":"LaplMatrix(backend, FTB, FeF::ScalarElement, FeT::ScalarElement, Grid, QuadOrd, Jacobi)\n\nAssembles the global Laplacian (stiffness) matrix for a finite element method (FEM) discretization.\n\nArguments\n\nbackend: Computational backend to use (not used directly in this function).\nFTB: Additional backend or transformation information (not used directly in this function).\nFeF::ScalarElement: Finite element object for the test space (provides basis function gradients and global DoF mapping).\nFeT::ScalarElement: Finite element object for the trial space (provides basis function gradients and global DoF mapping).\nGrid: Grid or mesh object containing information about the domain, faces, and geometry.\nQuadOrd: Quadrature order to use for numerical integration.\nJacobi: Function that computes the Jacobian matrix, its determinant, and its pseudo-inverse for a given face and reference point.\n\nReturns\n\nLapl: Sparse matrix representing the assembled global Laplacian (stiffness) matrix.\n\nDescription\n\nThis function computes the global Laplacian matrix by looping over all faces of the mesh, performing numerical integration using the specified quadrature rule, and assembling local element matrices into the global sparse matrix. The gradients of the basis functions are mapped from the reference element to the physical element using the Jacobian and its pseudo-inverse.\n\nNotes\n\nThe function assumes 2D elements and uses two components for gradients.\nThe local-to-global mapping for degrees of freedom is provided by FeT.Glob and FeF.Glob.\nThe function is optimized for performance using @inbounds and preallocated arrays.\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#CGDycore.FEMSei.DivRhs!","page":"Stiffness Matrix","title":"CGDycore.FEMSei.DivRhs!","text":"DivRhs!(backend, FTB, Div, FeT::ScalarElement, u, uFeF::HDivConfElement,       Grid, ElemType::Grids.ElementType, QuadOrd, Jacobi)\n\nAssembles the right-hand side vector for the divergence operator in a finite element method (FEM) context, specifically for scalar test functions and H(div)-conforming trial functions.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: Finite element basis or related data structure.\nDiv: Output vector to accumulate the divergence right-hand side contributions (modified in-place).\nFeT::ScalarElement: Scalar finite element type for the test space.\nu: Global vector of degrees of freedom for the H(div)-conforming field.\nuFeF::HDivConfElement: H(div)-conforming finite element type for the trial space.\nGrid: Grid or mesh data structure containing face and orientation information.\nElemType::Grids.ElementType: Element type descriptor for quadrature rule selection.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Jacobian or transformation data (not used directly in this function).\n\nDescription\n\nFor each face in the grid, this function:\n\nEvaluates basis functions and their divergences at quadrature points.\nComputes local contributions to the divergence right-hand side by integrating the product of test and trial functions over each face, taking into account face orientation and quadrature weights.\nAssembles these local contributions into the global Div vector.\n\nNotes\n\nThe function assumes 2D reference elements and that basis function evaluations are provided as callable objects.\nThe function is intended for use in mixed finite element methods, such as those involving H(div) spaces (e.g., Raviart-Thomas elements).\nAll operations are performed in-place for efficiency.\n\nIn-place Behavior\n\nThe Div vector is updated in-place with the assembled right-hand side contributions.\n\nPerformance\n\nUses @inbounds for performance; ensure input data is valid to avoid out-of-bounds errors.\n\n\n\n\n\nDivRhs!(backend, FTB, Div, u, uFeF::HDivKiteDElement, FeT::ScalarElement, Grid, ElemType::Grids.ElementType,       QuadOrd, Jacobi)\n\nAssembles the right-hand side vector for the divergence operator in a finite element method (FEM) context, specifically for mixed formulations involving H(div) elements on quadrilateral (kite) meshes.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: (Purpose not specified in the code snippet; likely a finite element transformation or buffer).\nDiv: Output vector to accumulate the divergence contributions (modified in-place).\nu: Input vector of degrees of freedom for the H(div) field.\nuFeF::HDivKiteDElement: H(div) finite element definition for the face elements.\nFeT::ScalarElement: Scalar finite element definition for the test space.\nGrid: Grid structure containing mesh and face information.\nElemType::Grids.ElementType: Element type descriptor for quadrature rule selection.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: (Purpose not specified in the code snippet; possibly a flag or structure for Jacobian transformations).\n\nDescription\n\nPrecomputes basis function values and their divergences at quadrature points for both the element interior and its edges.\nLoops over all faces in the grid, assembling local contributions to the divergence right-hand side vector.\nIntegrates both over the element interior and its boundaries using appropriate quadrature rules.\nHandles orientation of faces and global-to-local degree of freedom mappings.\nAccumulates the computed local divergence contributions into the global Div vector.\n\nNotes\n\nThe function is intended for use in mixed FEM formulations, such as those arising in incompressible flow or electromagnetics.\nAssumes that the finite element types and grid structures provide the necessary basis function evaluation and mapping utilities.\nUses in-place modification for performance.\n\nSee also\n\n[QuadRule]: For quadrature rule generation.\n[HDivKiteDElement], [ScalarElement]: For finite element definitions.\n\n\n\n\n\nDivRhs!(backend, FTB, Div, u, uFeF::HDivKiteDElement, h, hFeF::ScalarElement, FeT::ScalarElement, Grid,       ElemType::Grids.ElementType, QuadOrd, Jacobi)\n\nAssembles the right-hand side (RHS) vector for the divergence operator in a finite element method (FEM) context, specifically for mixed finite element spaces involving H(div) and scalar elements on a kite-shaped reference element.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: (Purpose not specified; likely a finite element basis or transformation object.)\nDiv: Output vector to accumulate the divergence RHS contributions (modified in-place).\nu: Vector of degrees of freedom (DoFs) for the H(div) field.\nuFeF::HDivKiteDElement: H(div) finite element object for the vector field.\nh: Vector of DoFs for the scalar field.\nhFeF::ScalarElement: Scalar finite element object for the scalar field.\nFeT::ScalarElement: Scalar finite element object for the test space.\nGrid: Grid or mesh structure containing element and face information.\nElemType::Grids.ElementType: Type of the element (e.g., reference kite).\nQuadOrd: Quadrature order for numerical integration.\nJacobi: (Purpose not specified; possibly a flag or structure for Jacobi preconditioning or integration.)\n\nDescription\n\nComputes local contributions to the divergence RHS by evaluating basis functions and their divergences at quadrature points.\nIntegrates over both the element interior and its faces/edges using appropriate quadrature rules.\nAccumulates the results into the global RHS vector Div using the global DoF mapping.\n\nNotes\n\nThe function is intended for use in mixed FEM formulations, such as those arising in fluid dynamics or electromagnetics.\nAssumes that the basis functions and their divergences are provided as callable objects in the finite element structures.\nUses in-place modification for performance.\n\nIn-place\n\nModifies the Div vector in-place.\n\nPerformance\n\nUses @inbounds and preallocated arrays for efficiency.\nSuitable for use in performance-critical assembly loops.\n\nSee also\n\nQuadRule\nHDivKiteDElement\nScalarElement\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#CGDycore.FEMSei.GradRhs!","page":"Stiffness Matrix","title":"CGDycore.FEMSei.GradRhs!","text":"GradRhs!(backend, FTB, Grad, h, hFeF::ScalarElement, FeT::HDivConfElement, Grid, ElemType::Grids.ElementType,        QuadOrd, Jacobi)\n\nAssembles the right-hand side (RHS) contribution for the gradient operator in a finite element method (FEM) context, specifically for mixed formulations involving scalar and HDiv-conforming elements.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: (Purpose not specified in the code snippet; likely a data structure for finite element assembly).\nGrad: Array to accumulate the assembled gradient RHS contributions (modified in-place).\nh: Array of scalar field degrees of freedom (DoFs).\nhFeF::ScalarElement: Scalar finite element descriptor for the field h.\nFeT::HDivConfElement: HDiv-conforming finite element descriptor for the test space.\nGrid: Grid or mesh data structure containing face and orientation information.\nElemType::Grids.ElementType: Element type descriptor (e.g., triangle, quadrilateral).\nQuadOrd: Quadrature order for numerical integration.\nJacobi: (Purpose not specified in the code snippet; possibly a flag or structure for Jacobian handling).\n\nDescription\n\nFor each face in the grid, this function:\n\nEvaluates basis functions and their divergences at quadrature points.\nComputes local contributions to the gradient RHS using quadrature.\nAssembles these local contributions into the global Grad array.\n\nThe function is optimized with @inbounds for performance and assumes that the basis function arrays and grid structures are properly initialized.\n\nNotes\n\nThe function modifies Grad in-place.\nThe function assumes that the basis function arrays (phi, Divphi) are callable with reference coordinates.\nThe purpose of backend, FTB, and Jacobi is not fully specified in the provided code.\n\nSee Also\n\nScalarElement\nHDivConfElement\nQuadRule\n\n\n\n\n\nGradRhs!(backend, FTB, Grad, h, hFeF::ScalarElement, u, uFeF::HDivKiteDElement, FeT::HDivKiteDElement, Grid,        ElemType::Grids.ElementType, QuadOrd, Jacobi)\n\nAssembles the gradient right-hand side (RHS) vector for a finite element method (FEM) problem involving scalar and vector fields on a grid with kite-shaped elements.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: (Purpose not specified in code snippet; likely a context or buffer object).\nGrad: Array to accumulate the assembled gradient RHS.\nh: Array of scalar field values (e.g., height or pressure) at global degrees of freedom.\nhFeF::ScalarElement: Scalar finite element function space for h.\nu: Array of vector field values (e.g., velocity) at global degrees of freedom.\nuFeF::HDivKiteDElement: H(div) finite element function space for u on kite-shaped elements.\nFeT::HDivKiteDElement: H(div) finite element function space for test functions on kite-shaped elements.\nGrid: Grid structure containing mesh and face information.\nElemType::Grids.ElementType: Type of element used in the grid.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for coordinate transformations.\n\nDescription\n\nThis function computes the local contributions to the gradient RHS vector for each face in the grid, using quadrature rules for both the element interior and its boundaries. It evaluates basis functions and their divergences at quadrature points, transforms field values to the physical domain, and assembles the contributions into the global RHS vector.\n\nThe function supports mixed finite element spaces (scalar and H(div) vector fields) and handles the mapping between reference and physical elements. It is designed for use in discontinuous Galerkin or mixed FEM formulations, particularly for problems involving conservation laws or fluid dynamics.\n\nNotes\n\nThe function modifies Grad in-place.\nAssumes that the finite element spaces and grid structures are properly initialized and compatible.\nThe function is performance-oriented, using @inbounds and preallocated arrays to minimize allocations and bounds checking.\n\nSee Also\n\nQuadRule\nScalarElement\nHDivKiteDElement\nGrids.ElementType\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#CGDycore.FEMSei.CurlMatrix","page":"Stiffness Matrix","title":"CGDycore.FEMSei.CurlMatrix","text":"CurlMatrix(backend, FTB, FeF::HCurlConfElement, FeT::ScalarElement, Grid, QuadOrd, Jacobi)\n\nAssembles the curl matrix for a finite element method (FEM) problem involving an HCurlConfElement (typically a vector-valued element with curl-conforming basis functions) and a ScalarElement (typically a scalar-valued element). The resulting sparse matrix represents the action of the curl operator in the FEM discretization.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU, etc.).\nFTB: Additional backend or finite element type information (usage depends on context).\nFeF::HCurlConfElement: The finite element object representing the curl-conforming (vector-valued) basis functions.\nFeT::ScalarElement: The finite element object representing the scalar-valued basis functions.\nGrid: The grid or mesh structure containing information about faces, orientations, and global DoF mappings.\nQuadOrd: The order of the quadrature rule to use for numerical integration.\nJacobi: Jacobi data or transformation (usage depends on context).\n\nReturns\n\nCurl: A sparse matrix representing the assembled curl operator between the given finite element spaces.\n\nDetails\n\nUses numerical quadrature to integrate the product of test and trial functions (and their curls) over each face of the grid.\nHandles orientation of faces and global degree-of-freedom (DoF) mapping.\nEfficiently assembles the matrix in sparse format.\n\nNotes\n\nAssumes that FeT.phi and FeF.Curlphi are arrays of function handles for evaluating basis functions and their curls at quadrature points.\nThe function is performance-optimized using @inbounds and preallocated arrays.\n\n\n\n\n\nCurlMatrix(backend, FTB, FeF::HCurlKiteDElement, FeT::ScalarElement, Grid, QuadOrd, Jacobi)\n\nAssembles the curl matrix for a finite element method (FEM) discretization involving an HCurlKiteDElement (vector-valued, H(curl)-conforming element) and a ScalarElement (scalar-valued element) over a given grid.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: Finite element type or basis information (purpose depends on context).\nFeF::HCurlKiteDElement: The H(curl)-conforming finite element object for the face (vector-valued).\nFeT::ScalarElement: The scalar-valued finite element object for the test function.\nGrid: The computational grid or mesh structure.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Jacobian or transformation information for mapping reference to physical elements.\n\nReturns\n\nCurl: A sparse matrix representing the assembled curl operator coupling the given finite element spaces.\n\nDetails\n\nComputes basis and curl-basis functions at quadrature points on both the reference element and its edges.\nIntegrates the contributions using quadrature rules for both the element interior and its boundaries.\nAssembles the local contributions into a global sparse matrix using the global degree-of-freedom (DoF) mappings.\nThe resulting matrix can be used in FEM formulations involving curl operators, such as in electromagnetics or fluid dynamics.\n\nNotes\n\nAssumes that FeF and FeT provide callable basis and curl-basis functions, as well as global DoF mappings.\nThe function is performance-optimized using @inbounds and preallocated arrays.\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#CGDycore.FEMSei.GradMatrix","page":"Stiffness Matrix","title":"CGDycore.FEMSei.GradMatrix","text":"GradMatrix(backend, FTB, FeF::ScalarElement, FeT::HDivConfElement, Grid, QuadOrd, Jacobi)\n\nAssembles the gradient matrix for a finite element method (FEM) problem involving a scalar element (FeF) and an H(div)-conforming element (FeT) on a given grid.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: Finite element type or basis (usage context-dependent).\nFeF::ScalarElement: Scalar finite element object, providing basis functions and gradients.\nFeT::HDivConfElement: H(div)-conforming finite element object, providing vector-valued basis functions.\nGrid: Grid or mesh structure containing geometric and topological information.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nReturns\n\nGrad: Sparse matrix representing the assembled gradient operator between the given finite element spaces.\n\nDescription\n\nThe function computes the local contributions to the gradient matrix for each face in the grid using numerical quadrature. It evaluates the basis functions and their gradients at quadrature points, applies the appropriate geometric transformations, and assembles the global sparse matrix.\n\nNotes\n\nThe function assumes that FeF and FeT provide callable basis and gradient functions.\nThe grid structure must provide face orientation and global degree-of-freedom (DoF) mappings.\nThe assembly is performed in a memory-efficient way using sparse matrix construction.\n\n\n\n\n\nGradMatrix(backend, FTB, FeF::ScalarElement, FeT::HDivKiteDElement, Grid, QuadOrd, Jacobi)\n\nAssembles the gradient matrix for a finite element method (FEM) discretization involving a scalar element (FeF) and an H(div) kite element (FeT) on a given grid.\n\nArguments\n\nbackend: Computational backend to use for matrix assembly.\nFTB: Additional backend or transformation information (purpose depends on context).\nFeF::ScalarElement: Scalar finite element providing basis functions and gradients.\nFeT::HDivKiteDElement: H(div) finite element providing vector-valued basis functions.\nGrid: Grid structure containing mesh and face information.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nReturns\n\nGrad: Sparse matrix representing the assembled gradient operator.\n\nDescription\n\nThe function computes the local contributions to the gradient matrix by evaluating basis functions and their gradients at quadrature points in the reference element and on its edges. It then maps these contributions to the global matrix using the grid's connectivity and orientation information. The resulting sparse matrix can be used in FEM solvers for problems involving mixed formulations or H(div) spaces.\n\nNotes\n\nThe function assumes that FeF and FeT provide callable basis and gradient functions indexed by degree of freedom and component.\nThe assembly uses in-place operations and preallocated arrays for efficiency.\nThe function is specialized for 2D elements with two components and their corresponding edge integrals.\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#CGDycore.FEMSei.GradHeightSquared!","page":"Stiffness Matrix","title":"CGDycore.FEMSei.GradHeightSquared!","text":"GradHeightSquared!(backend, FTB, Rhs, FeT::HDivConfElement, h, hFeF::ScalarElement,             Grid, ElemType::Grids.ElementType, QuadOrd, Jacobi)\n\nAssembles the contribution of the gradient of the squared height field to the right-hand side vector Rhs for a finite element method (FEM) discretization, typically used in shallow water or similar PDEs.\n\nArguments\n\nbackend: Computational backend or context (not used directly in this function).\nFTB: Additional backend or context parameter (not used directly in this function).\nRhs: The right-hand side vector to be updated in-place.\nFeT::HDivConfElement: The finite element configuration for the vector-valued (H(div)) space.\nh: The global vector of height field values.\nhFeF::ScalarElement: The finite element configuration for the scalar (height) field.\nGrid: The grid or mesh structure containing face and connectivity information.\nElemType::Grids.ElementType: The element type used for quadrature rule selection.\nQuadOrd: The order of the quadrature rule.\nJacobi: The Jacobian or transformation information (not used directly in this function).\n\nDescription\n\nFor each face in the grid, the function:\n\nInterpolates the height field h at quadrature points using the scalar basis functions.\nComputes the divergence of the vector basis functions at quadrature points.\nAssembles the local contributions of the gradient of the squared height (∇(h^2)) to the global right-hand side vector Rhs, scaled by gravity.\n\nNotes\n\nThe function assumes that the basis functions and their divergences are provided as callable objects.\nThe gravity constant Grav is hardcoded as 9.80616.\nThe function operates in-place and is performance-optimized with @inbounds and preallocated arrays.\n\nModifies\n\nRhs: The right-hand side vector is updated in-place with the assembled contributions.\n\nSee also\n\nQuadRule\nHDivConfElement\nScalarElement\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#CGDycore.FEMSei.GradKinHeight!","page":"Stiffness Matrix","title":"CGDycore.FEMSei.GradKinHeight!","text":"GradKinHeight!(backend, FTB, Rhs, h, hFeF::ScalarElement, u, uFeF::HDivConfElement,            FeT::HDivConfElement, Grid, ElemType::Grids.ElementType, QuadOrd, Jacobi)\n\nAssembles the gradient of the kinetic height term for a finite element method (FEM) discretization, and adds the local contributions to the global right-hand side vector Rhs.\n\nArguments\n\nbackend: Computational backend (not used directly in this function).\nFTB: (Purpose not specified in the code snippet).\nRhs: Global right-hand side vector to be updated in-place.\nh: Vector of height values at global degrees of freedom.\nhFeF::ScalarElement: Scalar finite element descriptor for the height field.\nu: Vector of velocity values at global degrees of freedom.\nuFeF::HDivConfElement: H(div)-conforming finite element descriptor for the velocity field.\nFeT::HDivConfElement: H(div)-conforming finite element descriptor for the test functions.\nGrid: Grid structure containing mesh and face information.\nElemType::Grids.ElementType: Element type for quadrature rule selection.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nDescription\n\nFor each face in the grid, this function:\n\nEvaluates basis functions and their divergences at quadrature points.\nMaps local degrees of freedom to global indices and gathers local solution values.\nComputes the local kinetic energy and potential energy contributions at quadrature points.\nIntegrates these contributions using the quadrature rule and assembles them into the global right-hand side vector Rhs.\n\nThe gravitational constant is hardcoded as Grav = 9.80616.\n\nNotes\n\nThe function operates in-place on Rhs.\nAssumes that the finite element descriptors (hFeF, uFeF, FeT) and the grid structure are properly initialized and compatible.\nThe function is performance-oriented, using @inbounds to skip bounds checking in loops.\n\nReturns\n\nNothing. The function updates Rhs in-place.\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#CGDycore.FEMSei.GradKinHeightInter!","page":"Stiffness Matrix","title":"CGDycore.FEMSei.GradKinHeightInter!","text":"GradKinHeightInter!(backend, FTB, Rhs, h, hFeF::ScalarElement, u, uFeF::HDivConfElement,              FeT::HDivConfElement, Grid, ElemType::Grids.ElementType, QuadOrd, Jacobi)\n\nAssembles the gradient of the kinetic height interaction term for a finite element method (FEM) discretization, and adds its contribution to the right-hand side vector Rhs.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: (Purpose not specified in the code snippet; likely a data structure related to the finite element assembly).\nRhs: Right-hand side vector to be updated in-place.\nh: Vector of height (scalar field) degrees of freedom.\nhFeF::ScalarElement: Scalar finite element descriptor for the height field.\nu: Vector of velocity (vector field) degrees of freedom.\nuFeF::HDivConfElement: H(div)-conforming finite element descriptor for the velocity field.\nFeT::HDivConfElement: H(div)-conforming finite element descriptor for the test functions.\nGrid: Grid or mesh data structure containing face and element information.\nElemType::Grids.ElementType: Type of the finite element (e.g., triangle, quadrilateral).\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for the mapping from reference to physical element.\n\nDescription\n\nThis function computes the local contributions of the gradient of the kinetic height interaction term for each face in the grid, using numerical quadrature. It evaluates basis functions and their divergences at quadrature points, transforms velocity components, and assembles the contributions into the global right-hand side vector Rhs. The gravitational constant is hardcoded as Grav = 9.80616.\n\nNotes\n\nThe function operates in-place and assumes all input arrays are properly sized and initialized.\nThe function is performance-optimized using @inbounds to skip array bounds checking.\nThe function is intended for use in the assembly phase of a mixed finite element method for shallow water or similar PDEs.\n\nSee also\n\n[ScalarElement]\n[HDivConfElement]\n[QuadRule]\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#CGDycore.FEMSei.CrossRhs!","page":"Stiffness Matrix","title":"CGDycore.FEMSei.CrossRhs!","text":"CrossRhs!(backend, FTB, Cross, FeT::HDivElement, u, uFeF::HDivElement, Grid,         ElemType::Grids.ElementType, QuadOrd, Jacobi)\n\nAssembles the right-hand side vector contribution for the cross product (Coriolis) term in a finite element method (FEM) context, specifically for HDiv-conforming elements on a given grid.\n\nArguments\n\nbackend: Computational backend (e.g., for parallelization or hardware abstraction).\nFTB: (Unused in this function, possibly for future extension or interface compatibility).\nCross: Vector to accumulate the assembled right-hand side contributions.\nFeT::HDivElement: Test finite element (HDiv-conforming) structure.\nu: Global solution vector (degrees of freedom).\nuFeF::HDivElement: Trial finite element (HDiv-conforming) structure.\nGrid: Grid structure containing mesh and face information.\nElemType::Grids.ElementType: Element type descriptor for quadrature rule selection.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nDescription\n\nFor each face in the grid, the function:\n\nEvaluates basis functions at quadrature points.\nMaps local degrees of freedom to global solution vector.\nComputes the mapped solution at quadrature points.\nApplies the Coriolis operator (cross product with a vector field k).\nIntegrates the result against test functions using quadrature.\nAssembles the local contributions into the global right-hand side vector Cross.\n\nNotes\n\nAssumes 3D vector fields and HDiv-conforming elements.\nThe Coriolis operator is computed via the Coriolis function, which returns a scalar field and a vector k.\nThe function is performance-oriented, using @inbounds for loop optimization.\n\nSee Also\n\nCoriolis\nQuadRule\nHDivElement\n\n\n\n\n\nCrossRhs!(backend, FTB, Cross, q, qFeF::ScalarElement, u, uFeF::HDivElement, FeT::HDivElement, Grid,         ElemType::Grids.ElementType, QuadOrd, Jacobi)\n\nAssembles the right-hand side vector for the cross product term in a finite element method (FEM) context, specifically for mixed finite element spaces involving scalar and H(div) elements.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: (Purpose not specified in code snippet; likely a workspace or buffer).\nCross: Output vector to accumulate the cross product right-hand side contributions.\nq: Coefficient vector for the scalar field.\nqFeF::ScalarElement: Scalar finite element descriptor for q.\nu: Coefficient vector for the H(div) field.\nuFeF::HDivElement: H(div) finite element descriptor for u.\nFeT::HDivElement: H(div) finite element descriptor for the test space.\nGrid: Grid or mesh structure containing geometry and topology information.\nElemType::Grids.ElementType: Element type descriptor for quadrature rule selection.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical space.\n\nDescription\n\nFor each face in the grid, this function:\n\nEvaluates basis functions and their values at quadrature points.\nMaps local degrees of freedom to global vectors.\nComputes the mapped vector field and its cross product with a Coriolis-like vector.\nIntegrates the resulting expression using quadrature and accumulates the contributions to the global right-hand side vector.\n\nNotes\n\nThe function is performance-critical and uses in-place operations and preallocated buffers.\nAssumes that the finite element descriptors (qFeF, uFeF, FeT) provide basis function evaluation and global-to-local mapping.\nThe Coriolis function is expected to return a vector field and its associated vector at a given point.\n\nIn-place\n\nModifies the Cross vector in-place.\n\nSee also\n\nQuadRule\nCoriolis\nJacobi\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#CGDycore.FEMSei.Coriolis","page":"Stiffness Matrix","title":"CGDycore.FEMSei.Coriolis","text":"Coriolis(X, Form)\n\nCompute the local Coriolis parameter and unit vector for a given position.\n\nArguments\n\nX::AbstractVector{<:Real}: A 3-element vector representing the position in Cartesian coordinates.\nForm::String: Specifies the geometry. Use \"Sphere\" for spherical geometry, otherwise a default planar value is used.\n\nReturns\n\nqFLoc::Float64: The local Coriolis parameter.\nk::SVector{3, Float64}: The local unit vector (vertical direction).\n\nDescription\n\nIf Form is \"Sphere\", computes the Coriolis parameter based on the latitude derived from the position vector X on a sphere (assuming Earth-like rotation). Otherwise, returns a constant Coriolis parameter and a vertical unit vector for planar geometry.\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#CGDycore.FEMSei.DivMomentumVector!","page":"Stiffness Matrix","title":"CGDycore.FEMSei.DivMomentumVector!","text":"DivMomentumVector!(backend, FTB, Rhs, FeTHDiv::HDivElement, uHDiv, FeHDiv::HDivElement,             uVecDG, FeVecDG::VectorElement, Grid, ElemType::Grids.ElementType,             QuadOrd, Jacobi)\n\nAssembles the right-hand side (Rhs) vector for the divergence of the momentum equation in a finite element method (FEM) context, using mixed HDiv and DG elements.\n\nArguments\n\nbackend: Computational backend (e.g., CPU/GPU, not used directly in this function).\nFTB: (Unused in this function, possibly for future extension or interface compatibility).\nRhs: Array to be updated in-place with the assembled right-hand side vector.\nFeTHDiv::HDivElement: Test function finite element space (H(div) element).\nuHDiv: Coefficient vector for the H(div) field.\nFeHDiv::HDivElement: Trial function finite element space (H(div) element).\nuVecDG: Coefficient vector for the DG vector field.\nFeVecDG::VectorElement: Finite element space for the DG vector field.\nGrid: Grid structure containing mesh and topology information.\nElemType::Grids.ElementType: Element type (e.g., triangle or quadrilateral).\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian and related geometric quantities.\n\nDescription\n\nThis function computes the local contributions to the right-hand side vector for the divergence of the momentum equation, including both element and edge (upwind) terms. It supports both triangular and quadrilateral elements and handles the assembly of contributions from volume integrals and edge integrals (for upwinding).\n\nThe function:\n\nEvaluates basis functions and their derivatives at quadrature points.\nComputes local variables and geometric transformations.\nAssembles local contributions to the global right-hand side vector, including upwind fluxes across edges.\n\nNotes\n\nThe function assumes that the finite element spaces and grid structures are properly initialized and compatible.\nThe function is performance-oriented, using in-place updates and preallocated arrays.\nThe upwind flux computation distinguishes between left and right elements at each edge and applies the appropriate sign based on the upwind direction.\n\nSee Also\n\nQuadRule\nHDivElement\nVectorElement\nGrids.ElementType\nJacobi\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#CGDycore.FEMSei.DivMomentumVectorOld!","page":"Stiffness Matrix","title":"CGDycore.FEMSei.DivMomentumVectorOld!","text":"DivMomentumVectorOld!(backend, FTB, Rhs, FeTHDiv::HDivElement, uHDiv, FeHDiv::HDivElement,              uVecDG, FeVecDG::VectorElement, Grid, ElemType::Grids.ElementType,              QuadOrd, Jacobi)\n\nAssembles the right-hand side (Rhs) vector for the divergence of the momentum equation in a finite element method (FEM) context, using mixed HDiv and DG vector elements. This function computes local contributions on faces and edges of the mesh and accumulates them into the global Rhs vector.\n\nArguments\n\nbackend: Computational backend (e.g., CPU/GPU, not used directly in this function).\nFTB: (Purpose not specified in the code snippet; likely a data structure for finite element assembly).\nRhs: The global right-hand side vector to be assembled (modified in-place).\nFeTHDiv::HDivElement: Test function finite element (H(div) space).\nuHDiv: Coefficient vector for H(div) solution.\nFeHDiv::HDivElement: Trial function finite element (H(div) space).\nuVecDG: Coefficient vector for DG vector solution.\nFeVecDG::VectorElement: DG vector finite element.\nGrid: Mesh/grid data structure containing faces, edges, and geometric information.\nElemType::Grids.ElementType: Element type (e.g., triangle or quadrilateral).\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, determinant, and related geometric quantities for mapping reference to physical elements.\n\nDescription\n\nEvaluates basis functions and their derivatives at quadrature points for both H(div) and DG vector elements.\nLoops over all faces to compute local contributions to the Rhs vector using quadrature.\nComputes upwind fluxes and edge contributions for internal edges, handling both triangle and quadrilateral elements.\nAssembles all local contributions into the global Rhs vector, applying upwind stabilization on edges.\n\nNotes\n\nThe function is performance-oriented, using @inbounds and preallocated arrays to minimize allocations.\nAssumes specific data structures for finite elements and grid, including global-to-local DoF mappings and geometric information.\nThe function is tailored for 2D problems (triangles and quadrilaterals) and vector-valued fields.\n\nReturns\n\nModifies Rhs in-place; does not return a value.\n\nSee Also\n\nQuadRule\nHDivElement\nVectorElement\nGrids.ElementType\nJacobi\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#CGDycore.FEMSei.CurlVel!","page":"Stiffness Matrix","title":"CGDycore.FEMSei.CurlVel!","text":"CurlVel!(q, FeT, u, uFe::HDivElement, QuadOrd, ElemType, Grid, Jacobi)\n\nAssembles the right-hand side vector q for the weak form of the curl operator applied to a velocity field u in a finite element context. Specifically, computes the integral\n\n∫ (curl u) ⋅ v dx = -∫ u ⋅ (rot v) dx\n\nusing numerical quadrature over all faces of the grid.\n\nArguments\n\nq: Output vector to be assembled (modified in-place).\nFeT: Test function finite element type, containing basis and gradient information.\nu: Coefficient vector representing the velocity field in the HDiv space.\nuFe::HDivElement: Finite element type for the HDiv-conforming space, providing basis functions for u.\nQuadOrd: Quadrature order for numerical integration.\nElemType: Element type descriptor (e.g., triangle, quadrilateral).\nGrid: Grid structure containing mesh and face connectivity information.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nDetails\n\nInitializes quadrature rules and evaluates basis functions and their gradients at quadrature points.\nLoops over all faces in the grid, assembling local contributions to q using the provided velocity field u.\nApplies the Jacobian transformation to map reference element quantities to the physical element.\nAccumulates contributions using the quadrature weights and basis function gradients.\nSolves the local system using the LU factorization stored in FeT.LUM.\n\nNotes\n\nAssumes 2D or 3D vector fields, with appropriate mapping and transformation.\nThe function modifies q in-place.\nThe function is performance-optimized using @inbounds and preallocated arrays.\n\nSee also\n\n[QuadRule]\n[HDivElement]\n[ldiv!]\n\n\n\n\n\nCurlVel!(q, FeT, u, uFe::HDivElement, h, hFe::ScalarElement, QuadOrd, ElemType, Grid, Jacobi)\n\nAssembles the right-hand side vector q for the weak form of the curl-velocity operator in a finite element method (FEM) context. Specifically, it computes the integral\n\n∫ q * v dx = ∫ (curl u) * v dx = -∫ u * rot(v) dx\n\nover all faces of the computational grid, using the provided finite element spaces and quadrature rules.\n\nArguments\n\nq: Output vector to be assembled (modified in-place).\nFeT: Test function finite element type (provides basis functions and global indexing).\nu: Input vector field (typically velocity).\nuFe::HDivElement: Finite element description for the velocity field (H(div) space).\nh: Scalar field (e.g., height or pressure).\nhFe::ScalarElement: Finite element description for the scalar field.\nQuadOrd: Quadrature order for numerical integration.\nElemType: Element type (e.g., triangle, quadrilateral).\nGrid: Grid structure containing mesh and face information.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nDetails\n\nLoops over all faces in the grid, assembling local contributions to the global vector q.\nUses quadrature to evaluate integrals on each face.\nApplies the Piola transformation to map basis functions from reference to physical elements.\nHandles both vector and scalar finite element spaces.\nThe assembled vector q is solved in-place using the LU decomposition stored in FeT.LUM.\n\nNotes\n\nAssumes that all input structures (FeT, uFe, hFe, Grid) are properly initialized and compatible.\nThe function is performance-critical and uses in-place operations and @inbounds for efficiency.\n\n\n\n\n\n","category":"function"},{"location":"StiffMatrix/#Notes","page":"Stiffness Matrix","title":"Notes","text":"","category":"section"},{"location":"StiffMatrix/","page":"Stiffness Matrix","title":"Stiffness Matrix","text":"The function assumes that basis functions and their derivatives are provided in the element objects.\nThe Jacobian and its inverse are used for mapping and integration.\nOnly nonzero entries are stored in the sparse.","category":"page"},{"location":"Examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"This section provides various example initializations for numerical experiments with CGDycore.","category":"page"},{"location":"Examples/#Bickley-Jet-Planar","page":"Examples","title":"Bickley Jet Planar","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The classic Bickley jet setup is a standard test case for barotropic instability and nonlinear jet evolution in atmospheric and oceanic flows.","category":"page"},{"location":"Examples/#CGDycore.Examples.BickleyJetExample","page":"Examples","title":"CGDycore.Examples.BickleyJetExample","text":"BickleyJetExample <: Example\n\nImplements the classic \"Bickley jet\" initial condition, widely used to study barotropic instability and nonlinear jet evolution in atmospheric and oceanic flows.\n\nUsage\n\nprofile = BickleyJetExample()   initial_conditions = profile(Param, Phys)\n\nArguments\n\nParam: Parameter object containing jet and perturbation parameters (e.g., L, Ly, l, k, ϵ).\nPhys: Physical parameters (not directly used in this function).\n\nReturns\n\nA function local_profile(x, time) that computes the initial conditions at position x and time time:\n\nRho: Density (set to 1.0).\nu: Zonal velocity, consisting of the jet profile and perturbations.\nv: Meridional velocity, consisting of perturbations.\nw: Vertical velocity (set to 0.0).\nTh: Potential temperature (set to 1.0).\n\nPhysical Background\n\nThe Bickley jet is a model for a narrow, east-west (zonal) jet centered at y=0, defined by the velocity profile U = sech(y)^2.   A streamfunction Ψ = -tanh(y) describes the main flow structure.   Sinusoidal tracer fields and localized vortical perturbations (Gaussian-modulated cosines) are added to trigger barotropic instability and jet meandering.   Velocity perturbations are computed from the streamfunction derivatives, resulting in small-scale turbulence superimposed on the jet.\n\nThis setup is commonly used to investigate the nonlinear evolution of jets, the formation of coherent structures, and the transition to turbulence (see Oceananigans.jl example and Beron-Vera et al. 2003).\n\nReferences\n\nBeron-Vera, F. J., Olascoaga, M. J., & Brown, M. G. (2003).   \"The Nonlinear Evolution of Bickley Jets\". Journal of Physical Oceanography, 33(10), 2173–2188.   Link\n\n\n\n\n\n","category":"type"},{"location":"Examples/#Modon-Collision","page":"Examples","title":"Modon Collision","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The Modon collision example initializes two interacting modons (coherent vortex structures), which are used to study vortex dynamics, wave interactions, and nonlinear evolution in geophysical flows.","category":"page"},{"location":"Examples/#CGDycore.Examples.ModonCollisionExample","page":"Examples","title":"CGDycore.Examples.ModonCollisionExample","text":"ModonCollisionExample <: Example\n\nImplements the initial condition for a modon collision on the sphere, following the setup in  McRae & Dritschel (2018), \"The modon test: A barotropic test case for numerical methods on the sphere\".\n\nUsage\n\nprofile = ModonCollisionExample()\ninitial_conditions = profile(Param, Phys)\n\nArguments\n\nParam: Parameter object containing modon parameters (e.g., modon centers, radii, amplitudes).\nPhys: Physical parameters (e.g., gravity, planetary radius).\n\nReturns\n\nA function local_profile(x, time) that computes the initial conditions at position x and time time:\n\nRho: Layer depth (height field).\nu: Zonal velocity.\nv: Meridional velocity.\nw: Vertical velocity (set to 0.0).\nTh: Passive tracer or potential temperature (set to 1.0).\n\nReference\n\nMcRae, A. T. T., & Dritschel, D. G. (2018).  \"The modon test: A barotropic test case for numerical methods on the sphere.\"  Geoscientific Model Development, 11(2), 645–655.  Link\nLin, S.-J., Chen, J.-H., Harris, L. M., & Zhou, L. (2017).  \"Colliding modons on the sphere: A barotropic test case for numerical methods.\"  Geoscientific Model Development, 10(10), 3801–3817. Link\n\n\n\n\n\n","category":"type"},{"location":"Examples/#Galewsky","page":"Examples","title":"Galewsky","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The Galewsky test case is a standard barotropic instability benchmark on the sphere, featuring a zonal jet and a localized perturbation. It is widely used to assess the performance of global shallow water models.","category":"page"},{"location":"Examples/#CGDycore.Examples.GalewskyExample","page":"Examples","title":"CGDycore.Examples.GalewskyExample","text":"GalewskyExample <: Example\n\nImplements the Galewsky barotropic instability initial condition, a standard test case for shallow water models on the sphere.\n\nUsage\n\nprofile = GalewskyExample()   initial_conditions = profile(Param, Phys)\n\nArguments\n\nParam: Parameter object containing Galewsky test parameters (e.g., H0G, hH, alphaG, betaG, lat0G, lat1G, uM, eN).\nPhys: Physical parameters (e.g., Grav, Omega, RadEarth).\n\nReturns\n\nA function local_profile(x, time) that computes the initial conditions at position x and time time:\n\nRho: Layer thickness (height field).\nu: Zonal velocity.\nv: Meridional velocity (set to 0).\nw: Vertical velocity (set to 0).\nTh: Potential temperature (set to 1).\n\nPhysical Background\n\nThe Galewsky test case is designed to study barotropic instability and the nonlinear evolution of a midlatitude jet on the sphere. The initial zonal velocity is confined between two latitudes and is in geostrophic balance with the height field. A localized height perturbation is added to trigger instability. This setup is widely used to benchmark shallow water models and study the development of jets and eddies (see Galewsky et al. 2004).\n\nReferences\n\nGalewsky, J., Scott, R. K., & Polvani, L. M. (2004).   \"An initial-value problem for testing numerical models of the global shallow-water equations.\" Tellus A: Dynamic Meteorology and Oceanography, 56(5), 429–440.   Link\n\n\n\n\n\n","category":"type"},{"location":"Examples/#Rossby-Haurwitz-Wave","page":"Examples","title":"Rossby-Haurwitz Wave","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The Haurwitz wave example initializes a steady, analytical wave solution on the sphere. It is commonly used to test the advection and wave propagation properties of numerical models.","category":"page"},{"location":"Examples/#CGDycore.Examples.HaurwitzExample","page":"Examples","title":"CGDycore.Examples.HaurwitzExample","text":"HaurwitzExample <: Example\n\nImplements the Haurwitz wave initial condition, a standard test case for the shallow water equations on the sphere, as described in Williamson et al. (1992).\n\nUsage\n\nprofile = HaurwitzExample()   initial_conditions = profile(Param, Phys)\n\nArguments\n\nParam: Parameter object containing Haurwitz wave parameters:\nω: Angular velocity of the wave (rad/s)\nK: Amplitude parameter (m/s)\nR: Zonal wavenumber (integer, e.g., 4)\nh0: Mean fluid depth (m)\nPhys: Physical parameters:\nGrav: Gravitational acceleration (m/s²)\nOmega: Planetary rotation rate (rad/s)\nRadEarth: Planetary radius (m)\n\nReturns\n\nA function local_profile(x, time) that computes the initial conditions at position x and time time:\n\nRho: Layer thickness (height field).\nu: Zonal velocity.\nv: Meridional velocity.\nw: Vertical velocity (set to 0).\nTh: Potential temperature (set to 1).\n\nPhysical Background\n\nThe Haurwitz wave is a classic analytic solution for the barotropic vorticity equation on the sphere, featuring a wavenumber-R pattern that propagates westward. It is widely used to test the accuracy and stability of global shallow water models.\n\nReferences\n\nWilliamson, D. L., Drake, J. B., Hack, J. J., Jakob, R., & Swarztrauber, P. N. (1992). \"A standard test set for numerical approximations to the shallow water equations in spherical geometry.\" Journal of Computational Physics, 102(1), 211–224. Link\n\n\n\n\n\n","category":"type"},{"location":"Examples/#More-Examples","page":"Examples","title":"More Examples","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Additional initializations and test cases are included in the Examples module and can be used analogously.","category":"page"},{"location":"#CGDycore.jl","page":"Home","title":"CGDycore.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation of CGDycore.jl – a flexible, high-performance finite element dynamical core for geophysical fluid dynamics, developed by the CliMA project.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CGDycore.jl provides a modular framework for the simulation of shallow water and atmospheric flows on various grids (e.g., cubed sphere, traingular, planar, icosahedral) using continuous and discontinuous Galerkin finite element methods. The code is designed for research and teaching in numerical weather prediction, climate modeling, and computational fluid dynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Key features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"High-order finite element discretizations (CG/DG)\nSupport for various grid types (cubed- and triangular sphere, planar, etc.)\nMatrix-free and efficient sparse matrix operators\nModular structure for easy extension and experimentation\nParallelization via MPI and GPU support","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Clone the repository and install dependencies:","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone https://github.com/CliMA/CGDycore.jl.git\ncd CGDycore.jl\njulia --project -e 'using Pkg; Pkg.instantiate()'","category":"page"},{"location":"","page":"Home","title":"Home","text":"Running an Example You can run a standard test case (e.g., the Bickley Jet) directly from the command line. For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project Jobs/FEM/BickleyJetFEMConsQuad","category":"page"},{"location":"","page":"Home","title":"Home","text":"or for the Galewsky test case:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project Jobs/FEM/GalewskyFEMConsQuad","category":"page"},{"location":"","page":"Home","title":"Home","text":"All job scripts in the Jobs/FEM/ directory can be made executable with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"chmod +x Jobs/FEM/*","category":"page"},{"location":"","page":"Home","title":"Home","text":"and then started directly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"./Jobs/FEM/BickleyJetFEMConsQuad","category":"page"},{"location":"","page":"Home","title":"Home","text":"Customizing Simulations You can adjust simulation parameters (e.g., grid type, order, simulation time) by editing the job scripts or passing command line arguments. See the Examples section for more details and available test cases.","category":"page"},{"location":"#Documentation-Structure","page":"Home","title":"Documentation Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mass Matrix: Theory and implementation of the mass matrix operator.\nStiffness Matrix: Details on the stiffness matrix and related operators.\nExamples: Overview of available test cases and how to run them.","category":"page"},{"location":"#Further-Information","page":"Home","title":"Further Information","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CGDycore.jl on GitHub\nCliMA Project","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are new to Julia, see the Julia Language documentation for installation and","category":"page"}]
}
