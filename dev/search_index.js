var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Sim","page":"API","title":"Sim","text":"","category":"section"},{"location":"api/#CGDycore.Grids.Edge","page":"API","title":"CGDycore.Grids.Edge","text":"Edge()\n\nThis is my documentation\n\n\n\n\n\n","category":"type"},{"location":"MassMatrix/#Massmatrix","page":"Mass Matrix","title":"Massmatrix","text":"","category":"section"},{"location":"MassMatrix/","page":"Mass Matrix","title":"Mass Matrix","text":"The mass matrix represents the inner product in the discretized function space.","category":"page"},{"location":"MassMatrix/","page":"Mass Matrix","title":"Mass Matrix","text":"For efficiency, we avoid explicitly assembling the mass matrix and instead","category":"page"},{"location":"MassMatrix/","page":"Mass Matrix","title":"Mass Matrix","text":"apply its action directly to fields.","category":"page"},{"location":"MassMatrix/","page":"Mass Matrix","title":"Mass Matrix","text":"In Julia, this is often achieved using matrix-free methods and","category":"page"},{"location":"MassMatrix/","page":"Mass Matrix","title":"Mass Matrix","text":"broadcasting, enabling efficient and flexible computations.","category":"page"},{"location":"MassMatrix/","page":"Mass Matrix","title":"Mass Matrix","text":"The mass matrix acts as a \"pseudo-operator\": it cannot be called directly, but can be applied to fields in a manner similar to other operators, leveraging broadcasting for performance and composability.","category":"page"},{"location":"MassMatrix/#General-Usage","page":"Mass Matrix","title":"General Usage","text":"","category":"section"},{"location":"MassMatrix/#CGDycore.FEMSei.MassMatrix","page":"Mass Matrix","title":"CGDycore.FEMSei.MassMatrix","text":"MassMatrix H(curl) elements\n\nAssembles the global mass matrix for a finite element discretization using H(curl) elements.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: Finite element basis or transformation object.\nFe::HCurlElement: The finite element object containing basis functions and related data for H(curl) elements.\nGrid: The computational grid or mesh structure containing faces and geometry information.\nQuadOrd: The order of the quadrature rule to use for numerical integration.\nJacobi: Function that computes the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nReturns\n\nM: The assembled sparse global mass matrix as a SparseMatrixCSC.\n\nDescription\n\nFor each face in the grid, the function computes the local mass matrix by integrating the inner product of the mapped basis functions over the reference element using a specified quadrature rule. The local contributions are then assembled into the global sparse mass matrix. Only non-negligible entries (greater than 1.e-6 in magnitude) are included in the global matrix.\n\nNotes\n\nThe function assumes that the basis functions and their mapping are provided in the Fe object.\nThe Jacobian and its pseudo-inverse are used to map basis functions from the reference to the physical element.\nThe function is tailored for H(curl) elements and may require adaptation for other element types.\n\n\n\n\n\nMassMatrix Scalar elements\n\nAssembles the global mass matrix for a finite element mesh.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: Finite element type or basis information.\nFe::ScalarElement: Scalar finite element object containing basis functions and related data.\nGrid: Grid or mesh structure containing information about faces and connectivity.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and its pseudo-inverse for mapping reference to physical elements.\n\nReturns\n\nM: Sparse matrix representing the assembled global mass matrix.\n\nDescription\n\nThis function computes the mass matrix by looping over all faces in the mesh, evaluating basis functions at quadrature points, and assembling local contributions into the global sparse matrix. The Jacobian is used to map reference element integrals to the physical domain. Only nonzero entries are stored in the sparse matrix.\n\nNotes\n\nThe function assumes that Fe.phi contains callable basis functions.\nThe global degree of freedom mapping is provided by Fe.Glob.\nThe quadrature rule is determined by FEMSei.QuadRule.\n\n\n\n\n\nMassMatrix Scalar elements with weights\n\nAssembles the mass matrix for a finite element method (FEM) problem using the provided scalar elements, quadrature order, and grid information.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: Finite element basis or related data structure.\nFe::ScalarElement: Finite element object representing the trial space.\nw: Vector of weights or coefficients for the weighted mass matrix.\nwFe::ScalarElement: Finite element object representing the weighting/test space.\nGrid: Grid or mesh data structure containing faces and connectivity.\nQuadOrd: Integer specifying the quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nReturns\n\nM: Sparse matrix representing the assembled mass matrix.\n\nDescription\n\nThe function computes the local mass matrix for each face in the grid using numerical quadrature, basis functions, and the provided weights. It then assembles these local matrices into a global sparse mass matrix. The Jacobian is used to map quadrature points from the reference element to the physical element, and the determinant is used to scale the integration weights.\n\nNotes\n\nThe function assumes that the basis functions (phi) are provided as callable objects in Fe and wFe.\nThe global indices for assembling the sparse matrix are taken from Fe.Glob and wFe.Glob.\nThe function supports assembling weighted mass matrices by incorporating the vector w and its associated basis functions.\n\n\n\n\n\nMassMatrix Vector elements\n\nAssembles the global mass matrix for a finite element discretization.\n\nArguments\n\nbackend: Computational backend to use (e.g., CPU, GPU).\nFTB: Finite element type or basis information.\nFe::VectorElement: Finite element object containing basis functions, degrees of freedom, and global mapping.\nGrid: Grid or mesh structure containing face and connectivity information.\nQuadOrd: Quadrature order for numerical integration.\nJacobi: Function to compute the Jacobian, its determinant, and pseudo-inverse for mapping reference to physical elements.\n\nReturns\n\nM: Sparse matrix representing the assembled global mass matrix.\n\nDescription\n\nFor each face in the grid, this function computes the local mass matrix using numerical quadrature and the provided basis functions. The local contributions are then assembled into the global sparse mass matrix using the global degree of freedom mapping.\n\nNotes\n\nThe function assumes 2D elements and vector-valued basis functions.\nThe quadrature rule and basis function evaluations are performed on the reference element and mapped to the physical element using the Jacobian.\nOnly nonzero entries are stored in the sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"#This-is-my-first-page","page":"Home","title":"This is my first page","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is my first sentence.","category":"page"}]
}
